#! /usr/bin/env python3
"""
    @Author: Thorsten liepert <thorsten@liepert.dev>
    @Date: 06.09.2024
    @CLicense: MIT
    @Description: A Discord bot that will handle log files generated by a SCUM server
                  and will send various events to discord.
"""
# pylint: disable=global-statement, too-many-branches, too-many-lines, import-error
import os
import sys
import random
import traceback
import gettext

from datetime import datetime
from zoneinfo import ZoneInfo

import discord
from discord.ext import commands
from discord.ext import tasks
from dotenv import load_dotenv

# pylint: disable=wrong-import-position
# sys.path.append('./')
from modules.datamanager import ScumLogDataManager
from modules.logparser import LoginParser, KillParser, BunkerParser, FamepointParser, \
    AdminParser, ChatParser
from modules.sftploader import ScumSFTPLogParser
from modules.output import Output
from modules.configmanager import ConfigManager
from modules.mytime import mytime
from command.online import Online
# pylint: enable=wrong-import-position

load_dotenv()
LOG_CHECK_INTERVAL = os.getenv("LOG_CHECK_INTERVAL")

if LOG_CHECK_INTERVAL is None:
    LOG_CHECK_INTERVAL = 60.0
else:
    LOG_CHECK_INTERVAL = float(LOG_CHECK_INTERVAL)

HELP_COMMAND = os.getenv("BOT_HELP_COMMAND")
if HELP_COMMAND is None:
    HELP_COMMAND = "buffi"


WEAPON_LOOKUP = {
    "Compound_Bow_C": "compund bow"
}

MAX_MESSAGE_LENGTH = 1000

heartbeat = datetime.now()

intents = discord.Intents.default()
intents.message_content = True
intents.members = True

client = commands.Bot(command_prefix="!",intents=intents)
lp: None

logging = Output()

@client.event
async def on_ready():
    """Function is called when bot is ready"""
    global lp
    global heartbeat
    guild = None
    for guild in client.guilds:
        if config.guild in (guild.name, str(guild.id)):
            # print("found")
            break
    logging.info(f"Starting Bot Version {config.version}")

    if guild is not None:
        logging.info(
            f'{client.user} is connected to the following guild:\n'
            f'{guild.name}(id: {guild.id})\n'
            'Starting log parser.'
        )
    #call database manager to initialize db
    db = ScumLogDataManager(config.database_file)

    # Open SFTP connection to the game server
    lp = ScumSFTPLogParser(server=config.sftp_server, port=config.sftp_port,
                           passwd=config.sftp_password, user=config.sftp_user,
                           logdirectoy=config.log_directory, database=config.database_file,
                           debug_callback=None)

    # Inital load of guild members
    await load_guild_members(db)

    # Start the loop that checks log files periodically
    if not log_parser_loop.is_running():
        logging.info("Starting main loop.")
        heartbeat = datetime.now()
        log_parser_loop.start()

    if not watchdog.is_running():
        logging.info("Starting main loop watchdog.")
        watchdog.start()

async def _reply(context, msg) -> None:
    if len(msg) > MAX_MESSAGE_LENGTH:
        chunks = []
        chunk = ""
        for line in msg.split("\n"):
            if len(chunk) + len(line) < MAX_MESSAGE_LENGTH:
                chunk += f"{line}\n"
            else:
                chunks.append(chunk)
                chunk = f"{line}\n"
        for _chunk in chunks:
            if config.config["reply"] == "same_channel":
                await context.reply(_chunk)
            else:
                await context.author.send(_chunk)
    else:
        if config.config["reply"] == "same_channel":
            await context.reply(msg)
        else:
            await context.author.send(msg)

async def _reply_author(context, msg) -> None:
    if len(msg) > MAX_MESSAGE_LENGTH:
        chunks = []
        chunk = ""
        for line in msg.split("\n"):
            if len(chunk) + len(line) < MAX_MESSAGE_LENGTH:
                chunk += f"{line}\n"
            else:
                chunks.append(chunk)
                chunk = f"{line}\n"
        for _chunk in chunks:
            await context.author.send(_chunk)
    else:
        await context.author.send(msg)

def _check_guild_roles(guild_roles, role) -> bool:
    retval = False
    for guild_role in guild_roles:
        if guild_role.name == role:
            retval = True
    return retval

def _check_user_bot_role(name: str, bot_role: str, super_admin: bool = False):
    db = ScumLogDataManager(config.database_file)
    user = db.get_guild_member(name)
    user_ok = False

    if len(user) == 0:
        if name == config.super_admin_user and super_admin:
            return True
        # user not in DB so return
        else:
            return False

    if user[name]['bot_role'] == "deny":
        return False

    if config.BOT_ROLES.index(user[name]['bot_role']) >= config.BOT_ROLES.index(bot_role):
        user_ok = True

    if name == config.super_admin_user and super_admin:
        user_ok = True

    return user_ok

def _get_guild_member_roles(member_name: str) -> list:
    roles= []
    for guild in client.guilds:
        if config.guild in (guild.name, str(guild.id)):
            for member in guild.members:
                if member.name == member_name:
                    roles = member.roles

    return roles

def _check_chat_allowed(channel: str) -> bool:
    retval = False
    if channel.lower() == "global" and config.config['publish_chat_global']:
        retval = True
    elif channel.lower() == "local" and config.config['publish_chat_local']:
        retval = True
    elif channel.lower() == "admin" and config.config['publish_chat_admin']:
        retval = True
    elif channel.lower() == "squad" and config.config['publish_chat_team']:
        retval = True

    return retval

def _convert_german_time(string):
    return datetime.strptime(string, "%Y.%m.%d-%H.%M.%S").strftime("%Y.%m.%d-%H:%M:%S")

async def send_debug_message(message):
    """Function will send debug messages"""
    channel = client.get_channel(int(config.debug_channel))
    await channel.send(message)

async def handle_login(msgs, file, dbconnection):
    """parse messages from login log files"""
    channel = client.get_channel(int(config.log_feed_channel))
    p = LoginParser()
    for m in msgs[file]:
        if not isinstance(m,set):
            for mm in str.split(m,"\n"):
                msg = p.parse(mm)
                if msg and dbconnection.check_message_send(msg["hash"]):
                    player_data = dbconnection.get_player_status(msg["username"])
                    if len(player_data) == 0:
                        player_data.append({'drone': False})
                    if not msg['drone'] and not player_data[0]['drone']:
                    # pylint: disable=line-too-long
                        if msg['state'] == "in":
                            log_msg = _("Player: {name}, logged in ").format(name=msg['username'])
                        else:
                            log_msg = _("Player: {name}, logged out ").format(name=msg['username'])
                        msg_str = log_msg
                        msg_str += f"@ [X={msg['coordinates']['x']} "
                        msg_str += f"Y={msg['coordinates']['y']} Z={msg['coordinates']['z']}]"
                        msg_str += f"(https://scum-map.com/en/map/place/{msg['coordinates']['x']}"
                        msg_str += f",{msg['coordinates']['y']},3)"

                        if config.config["publish_login"] and \
                            (datetime.now().timestamp() - mytime.get_timestamp(msg['timestamp']) < 600):
                            await channel.send(msg_str)
                    if msg['drone'] or player_data[0]['drone']:
                    # pylint: disable=line-too-long
                        if msg['state'] == "in":
                            log_msg = _("Player: {name}, logged in as drone ").format(name=msg['username'])
                        else:
                            log_msg = _("Player: {name}, logged out as drone ").format(name=msg['username'])

                if msg and dbconnection.check_message_send(msg["hash"]):
                    if not msg['drone'] and player_data[0]['drone']:
                        msg['drone'] = True
                    dbconnection.store_message_send(msg["hash"])
                    dbconnection.update_player(msg)
                    # pylint: enable=line-too-long
                    logging.DEBUG(log_msg)

async def handle_kills(msgs, file, dbconnection):
    """function to construct and send kill messages"""
    channel = client.get_channel(int(config.log_feed_channel))
    player_insults = [
        _('bad boy'),
        _('savage'),
        _('bandit'),
        _('hero'),
        _('murderer')
    ]

    player_insult = random.choice(player_insults)
    p = KillParser()
    for m in msgs[file]:
        if not isinstance(m,set):
            for mm in str.split(m,"\n"):
                msg = p.parse(mm)
                if msg and dbconnection.check_message_send(msg["hash"]):
                    if msg["event"]["Weapon"] in WEAPON_LOOKUP:
                        weapon = WEAPON_LOOKUP[[msg["event"]["Weapon"]]]
                    else:
                        weapon = msg["event"]["Weapon"]
                    # pylint: disable=line-too-long
                    msg_str = _("Player {killer} ").format(killer=msg['event']['Killer']['ProfileName'])
                    msg_str += _("was a {playerinsult} ").format(playerinsult=player_insult)
                    msg_str += _("and killed {victim} ").format(victim=msg['event']['Victim']['ProfileName'])
                    msg_str += _("with a {weapon}.").format(weapon=weapon)
                    # pylint: enable=line-too-long
                    if config.config["publish_kills"]:
                        await channel.send(msg_str)
                    dbconnection.store_message_send(msg["hash"])

async def handle_bunkers(msgs, file, dbconnection):
    """handle bunker events"""
    channel = client.get_channel(int(config.log_feed_channel))
    p = BunkerParser()
    for m in msgs[file]:
        if not isinstance(m,set):
            for mm in str.split(m,"\n"):
                msg = p.parse(mm)
                if msg and dbconnection.check_message_send(msg["hash"]):
                    # Bunker activaed

                    bunker_data = dbconnection.get_active_bunkers(msg['name'])
                    if len(bunker_data) == 0:
                        bunker_data.append({"active": 0})
                        bunker_data[0].update({"coordinates":{}})

                    if msg["active"] and bunker_data[0]['active'] == 0:
                        msg_str = _("Bunker {name} was activated. ").format(name=msg['name'])
                        if len(msg["coordinates"]) != 0:
                            msg_str += f"Coordinates @ [X={msg['coordinates']['x']} "
                            msg_str += f"Y={msg['coordinates']['y']} "
                            msg_str += f"Z={msg['coordinates']['z']}]"
                            msg_str += "(https://scum-map.com/en/map/place/"
                            msg_str += f"{msg['coordinates']['x']}"
                            msg_str += f",{msg['coordinates']['y']},3)"
                        elif len(bunker_data[0]['coordinates']) != 0:
                            msg_str += f"Coordinates @ [X={bunker_data[0]['coordinates']['x']} "
                            msg_str += f"Y={bunker_data[0]['coordinates']['y']} "
                            msg_str += f"Z={bunker_data[0]['coordinates']['z']}]"
                            msg_str += "(https://scum-map.com/en/map/place/"
                            msg_str += f"{bunker_data[0]['coordinates']['x']}"
                            msg_str += f",{bunker_data[0]['coordinates']['y']},3)"
                        else:
                            msg_str += _("Bunker coordinates unkown, ")
                            msg_str += _("it wasnt't discovered previously.")
                        if config.config["publish_bunkers"]:
                            await channel.send(msg_str)
                    dbconnection.update_bunker_status(msg)
                    dbconnection.store_message_send(msg["hash"])

async def handle_fame(msgs, file, dbconnection):
    """handle fame point events"""
    # channel = client.get_channel(int(config.log_feed_channel))
    fp = FamepointParser()
    for m in msgs[file]:
        if not isinstance(m,set):
            for mm in str.split(m,"\n"):
                msg = fp.parse(mm)
                if msg and dbconnection.check_message_send(msg["hash"]):
                    logging.info(f"Player: {msg['name']} has {msg['points']} Points.")
                    dbconnection.update_fame_points(msg)
                    dbconnection.store_message_send(msg["hash"])

async def handle_admin_log(msgs, file, dbconnection):
    """handle admin log events"""
    fp = AdminParser()
    for m in msgs[file]:
        if not isinstance(m,set):
            for mm in str.split(m,"\n"):
                msg = fp.parse(mm)
                if msg and dbconnection.check_message_send(msg["hash"]):
                    logging.info(f"Admin: {msg['name']}: {msg['type']} - {msg['action']}")
                    dbconnection.store_message_send(msg["hash"])
                    dbconnection.update_admin_audit(msg)
                    player_state = dbconnection.get_player_status(msg['name'])
                    log_msg = f"Player {msg['name']} used admin command {msg['type']}: {msg['action']}."
                    log_msg += f" Player was drone? {str(bool(player_state[0]['drone']))} "
                    log_msg += f"({str(player_state[0]['drone'])})"
                    logging.info(log_msg)
                    if config.config["publish_admin_log"] and player_state[0]['drone'] == 0:
                        channel = client.get_channel(int(config.log_feed_channel))
                        msg_str = f"{_convert_german_time(msg['time'])} - Admin: "
                        msg_str += _("{name} invoked ").format(name=msg['name'])
                        msg_str += f"{msg['type']}: {msg['action']}\n"
                        await channel.send(msg_str)

async def handle_chat(msgs, file, db: ScumLogDataManager):
    """handle chat messages"""
    parser = ChatParser()
    for m in msgs[file]:
        if not isinstance(m,set):
            for mm in str.split(m,"\n"):
                msg = parser.parse(mm)
                if msg and db.check_message_send(msg["hash"]):
                    logging.info(f"Chat: {msg['name']} - {msg['channel']}: {msg['message']}")
                    db.store_message_send(msg["hash"])
                    channel = client.get_channel(int(config.log_feed_channel))
                    if msg['channel'].lower() == "global":
                        channel = client.get_channel(int(config.log_chat_global_channel))
                    elif msg['channel'].lower() == "admin":
                        channel = client.get_channel(int(config.log_chat_admin_channel))
                    elif msg['channel'].lower() == "squad":
                        channel = client.get_channel(int(config.log_chat_team_channel))
                    elif msg['channel'].lower() == "local":
                        channel = client.get_channel(int(config.log_chat_local_channel))
                    if config.config["publish_chat"]:
                        msg_str = f"{_convert_german_time(msg['time'])} - "
                        msg_str += (f"{msg['name']} - {msg['channel']}: ")
                        msg_str += f"{msg['message']}\n"
                        if _check_chat_allowed(msg['channel']):
                            await channel.send(msg_str)

async def load_guild_members(db: ScumLogDataManager):
    """load guild members and add new members to database"""
    current_members = db.get_guild_member()
    logging.info("Updating guild members.")
    for guild in client.guilds:
        if config.guild in (guild.name, str(guild.id)):
            if guild.owner.name not in current_members:
                current_members.update({
                    guild.owner.name: {
                        "id": guild.owner.id,
                        "guild_role": "",
                        "bot_role": "owner"
                    }
                })
                db.update_guild_member(guild.owner.id, guild.owner.name,
                    "", "owner")

            for member in guild.members:
                update_member = False
                roles= []
                for role in guild.get_member(member.id).roles:
                    roles.append(role.name)

                if member.name not in current_members:
                    # add member
                    logging.info(f"Found new discord member: {member}.")
                    if member.name == guild.owner.name:
                        bot_role= "owner"
                    elif member.name == config.super_admin_user:
                        bot_role = "owner"
                    elif _check_guild_roles(member.roles, config.super_admin_role):
                        bot_role= "owner"
                    elif member.name == config.admin_user:
                        bot_role = "admin"
                    elif _check_guild_roles(member.roles, config.user_role):
                        bot_role= "user"
                    elif _check_guild_roles(member.roles, config.admin_role):
                        bot_role= "admin"
                    else:
                        bot_role = "deny"

                    current_members.update({
                        member.name: {
                            "id": member.id,
                            "guild_role": ",".join(roles),
                            "bot_role": bot_role
                        }
                    })
                    update_member = True
                else:
                    # update guild roles if necessary
                    bot_role = current_members[member.name]["bot_role"]
                    if _check_guild_roles(member.roles, config.user_role) \
                            and not _check_user_bot_role(member.name, "user"):
                        bot_role = "user"
                    elif not _check_guild_roles(member.roles, config.user_role) \
                            and current_members[member.name]["bot_role"] == "user":
                        bot_role = "deny"

                    if ",".join(roles) != current_members[member.name]["guild_role"] \
                            or bot_role != current_members[member.name]["bot_role"]:
                        logging.info(f"Update existing discord member: {member}")
                        current_members.update({
                            member.name: {
                                "id": member.id,
                                "guild_role": ",".join(roles),
                                "bot_role": bot_role
                            }
                        })

                        update_member = True

                if update_member:
                    db.update_guild_member(member.id, member.name,
                                           current_members[member.name]["guild_role"],
                                           current_members[member.name]["bot_role"])

            break

@tasks.loop(seconds=60)
async def watchdog():
    """A watchdog for the main loop"""
    logging.info("Watchdog execute.")
    _now = datetime.now()
    if _now.timestamp() - heartbeat.timestamp() > config.log_check_interval * 5:
        logging.error(f"Main loop not running for {config.log_check_interval * 5} seconds. \
                      Attempting to restart.")

        if log_parser_loop.is_running():
            logging.error("Main loop was still running, restart main loop.")
            log_parser_loop.restart()
        else:
            logging.error("Main loop was dead. Starting main loop.")
            log_parser_loop.start()

@tasks.loop(seconds=LOG_CHECK_INTERVAL)
async def log_parser_loop():
    """Loop to parse logfiles and handle outputs"""
    global heartbeat
    db = ScumLogDataManager(config.database_file)
    await client.wait_until_ready()
    msgs = await lp.scum_log_parse()
    if len(msgs) > 0:
        for file_key in msgs:
            if "login" in file_key:
                await handle_login(msgs, file_key, db)
            elif "kill" in file_key and "event" not in file_key:
                await handle_kills(msgs, file_key, db)
            elif "gameplay" in file_key:
                await handle_bunkers(msgs, file_key, db)
            elif "famepoints" in file_key:
                await handle_fame(msgs, file_key, db)
            elif "admin" in file_key:
                await handle_admin_log(msgs, file_key, db)
            elif "chat" in file_key:
                await handle_chat(msgs, file_key, db)

    if datetime.now().minute % 10 == 0:
        await load_guild_members(db)

    if datetime.now().hour == 0 and datetime.now().minute == 0:
        db.discard_old_logfiles(30*86400)
        db.discard_aged_messages(30*86400)
        db.discard_old_admin_audtis(60*86400)

    await _handle_schduled_restart()
    db.close()
    heartbeat = datetime.now()

@log_parser_loop.error
async def on_loop_error(error):
    """Error handler for the loop"""
    logging.error(f"Error during loop occoured: {error}")
    if log_parser_loop.failed() and not log_parser_loop.is_running():
        log_parser_loop.start()
    elif log_parser_loop.failed and log_parser_loop.is_running():
        log_parser_loop.restart()
    else:
        if not log_parser_loop.is_running():
            log_parser_loop.start()
        elif log_parser_loop.is_running():
            log_parser_loop.restart()

@client.command(name="debug")
async def command_debug(ctx, *args):
    """some debug functions"""
    if not config.experimental:
        return
    db = ScumLogDataManager(config.database_file)
    if args[0] == "dump_all":
        await _reply_author(ctx, _("Current configuration"))
        msg_str = ""
        for cfg in config.config.items():
            msg_str += f"{cfg[0]}: {cfg[1]}\n"
        await _reply_author(ctx, msg_str)

        await _reply_author(ctx, _("Members stored in DB."))
        members = db.get_guild_member()
        msg_str = ""
        for member, member_data in members.items():
            msg_str += f"{member} - Discord Role: {member_data['guild_role']}"
            msg_str += f" - Bot Role: {member_data['bot_role']}\n"
        await _reply_author(ctx, msg_str)

        await _reply_author(ctx, _("Current Environment"))
        msg_str = ""
        for key,value in os.environ.items():
            if key in config.ENV_AVAILABLE_KEYS:
                msg_str += f"{key}: {value}\n"

        await _reply_author(ctx, _("Guild members:"))
        for guild in client.guilds:
            if config.guild in (guild.name, guild.id):
                await _reply_author(ctx, str(client.guild.members))
        await _reply_author(ctx, msg_str)

@client.command(name="member")
async def command_member(ctx, *args):
    """ handle command member"""
    # pylint: disable=consider-using-dict-items
    db = ScumLogDataManager(config.database_file)
    msg_str = ""
    if not _check_user_bot_role(ctx.author.name, 'admin', True):
        await ctx.reply(_("You don't have permission to invoke this command."))
        return

    if len(args) == 0:
        members = db.get_guild_member()
        msg_str = _("Current members in database:\n")
        for member in members:
            msg_str += f"{member} - Discord Role: {members[member]['guild_role']}"
            msg_str += f" - Bot Role: {members[member]['bot_role']}\n"

    elif len(args) == 1:
        members = db.get_guild_member(args[0])
        if len(members) < 1:
            msg_str = _("No members stored in Database")
        else:
            msg_str = _("Current members in database:\n")
            for member in members:
                msg_str += f"{member} - Discord Role: {members[member]['guild_role']}"
                msg_str += f" - Bot Role: {members[member]['bot_role']}\n"

    elif len(args) == 2:
        # set bot_role of memeber
        # pylint: disable=line-too-long
        member = db.get_guild_member(args[0])
        if len(member) < 1:
            if ctx.guild:
                for _member in ctx.guild.members:
                    if _member.name == args[0]:
                        msg_str = _("Member {name} given bot role {role}").format(name=args[0], role=args[1])
                        db.update_guild_member(_member.id,args[0],
                                                   ",".join(_member.roles),args[1])
                if len(msg_str) == 0:
                    msg_str = _("Member {name} does not exist on Server.").format(name=args[0])
            else:
                msg_str = _("Member {name} not in database. Can't create member via DM.").format(name=args[0])
        else:
            if member[args[0]]["bot_role"] == args[1]:
                msg_str = _("Member {name} already has bot role {role}").format(name=args[0], role=args[1])
            else:
                msg_str = _("Member {name} given bot role {role}").format(name=args[0], role=args[1])
                db.update_guild_member(member[args[0]]['id'],args[0],
                                       member[args[0]]['guild_role'],args[1])

    else:
        await _reply_author(ctx, _("Too many arguments for command 'member'"))

    if len(msg_str) > 0:
        await _reply_author(ctx, msg_str)
    else:
        await _reply_author(ctx, _("No members in database!"))
    # pylint: enable=consider-using-dict-items, line-too-long

async def handle_command_audit(ctx, args):
    """ handle command audit"""
    db = ScumLogDataManager(config.database_file)
    msg_str = ""
    local_timezone = ZoneInfo('Europe/Berlin')
    if len(args) == 0:
        audit = db.get_admin_audit()
        for a in audit:
            msg_str += f"{datetime.fromtimestamp(a['timestamp'],
                        local_timezone).strftime('%Y-%m-%d %H:%M:%S')}: "
            msg_str += f"{a['username']} invoked "
            msg_str += f"{a['type']}: {a['action']}\n"
    elif args[0] == "age":
        if "d" in args[1]:
            _days = int(args[1].split("d")[0])
            age = mytime.get_date_for_age(_days)
        elif "m" in args[1]:
            _months = int(args[1].split("m")[0])
            age = mytime.get_date_for_age(_months * 30)
        else:
            age = 0

        audit = db.get_admin_audit('age', datetime.timestamp(age))
        for a in audit:
            msg_str += f"{datetime.fromtimestamp(a['timestamp'],
                        local_timezone).strftime('%Y-%m-%d %H:%M:%S')}: "
            msg_str += f"{a['username']} invoked "
            msg_str += f"{a['type']}: {a['action']}\n"
    else:
        msg_str = _("Command not supported!")

    if len(msg_str) > 0:
        if len(msg_str) > MAX_MESSAGE_LENGTH:
            chunks = []
            chunk = ""
            for line in msg_str.split("\n"):
                if len(chunk) + len(line) < MAX_MESSAGE_LENGTH:
                    chunk += f"{line}\n"
                else:
                    chunks.append(chunk)
                    chunk = f"{line}\n"

            for _chunk in chunks:
                await _reply_author(ctx, _chunk)
        else:
            await _reply_author(ctx, msg_str)
    else:
        await _reply_author(ctx, _("No entries in audit!"))

@client.command(name="audit")
async def command_audit(ctx, *args):
    """print audit log"""
    if ctx.guild:
        roles = []
        for role in ctx.author.roles:
            roles.append(role.name)

        if config.super_admin_role in roles or \
           _check_user_bot_role(ctx.author.name, 'admin', True):
            await handle_command_audit(ctx, args)
        else:
            await ctx.reply(_("You have no permission to execute this command!"))

    else:
        if config.super_admin_user == ctx.author.name or \
           _check_user_bot_role(ctx.author.name, 'admin', True):
            await handle_command_audit(ctx, args)
        else:
            await ctx.reply(_("You have no permission to execute this command!"))

async def handle_command_config(ctx, args):
    """ handle command config """
    db = ScumLogDataManager(config.database_file)
    if len(args) <= 0:
        msg = "Current config:\n"
        for cfg in config.config.items():
            msg += f"{cfg[0]}: {cfg[1]}\n"
        await _reply_author(ctx, msg)
        return

    if args[0] == "reply":
        if len(args) < 2:
            await _reply(ctx, _("Missing arguments."))
        else:
            if args[1] == "private":
                config.config.update({"reply": "private"})
            else:
                config.config.update({"reply": "same_channel"})

    if args[0] == "publish_login":
        if len(args) < 2:
            await _reply(ctx, _("Missing arguments."))
        else:
            if args[1].lower() == "true" or args[1] == "1":
                config.config.update({"publish_login": True})
            else:
                config.config.update({"publish_login": False})

    if args[0] == "publish_bunkers":
        if len(args) < 2:
            await _reply(ctx, _("Missing arguments."))
        else:
            if args[1].lower() == "true" or args[1] == "1":
                config.config.update({"publish_bunkers": True})
            else:
                config.config.update({"publish_bunkers": False})

    if args[0] == "publish_kills":
        if len(args) < 2:
            await _reply(ctx, _("Missing arguments."))
        else:
            if args[1].lower() == "true" or args[1] == "1":
                config.config.update({"publish_kills": True})
            else:
                config.config.update({"publish_kills": False})

    if args[0] == "publish_admin_log":
        if len(args) < 2:
            await _reply(ctx, _("Missing arguments."))
        else:
            if args[1].lower() == "true" or args[1] == "1":
                config.config.update({"publish_admin_log": True})
            else:
                config.config.update({"publish_admin_log": False})

    if args[0] == "publish_chat":
        if len(args) < 2:
            await _reply(ctx, _("Missing arguments."))
        else:
            if args[1].lower() == "true" or args[1] == "1":
                config.config.update({"publish_chat": True})
            else:
                config.config.update({"publish_chat": False})

    if args[0] == "publish_chat_global":
        if len(args) < 2:
            await _reply(ctx, _("Missing arguments."))
        else:
            if args[1].lower() == "true" or args[1] == "1":
                config.config.update({"publish_chat_global": True})
            else:
                config.config.update({"publish_chat_global": False})

    if args[0] == "publish_chat_local":
        if len(args) < 2:
            await _reply(ctx, _("Missing arguments."))
        else:
            if args[1].lower() == "true" or args[1] == "1":
                config.config.update({"publish_chat_local": True})
            else:
                config.config.update({"publish_chat_local": False})

    if args[0] == "publish_chat_team":
        if len(args) < 2:
            await _reply(ctx, _("Missing arguments."))
        else:
            if args[1].lower() == "true" or args[1] == "1":
                config.config.update({"publish_chat_team": True})
            else:
                config.config.update({"publish_chat_team": False})

    if args[0] == "publish_chat_admin":
        if len(args) < 2:
            await _reply(ctx, _("Missing arguments."))
        else:
            if args[1].lower() == "true" or args[1] == "1":
                config.config.update({"publish_chat_admin": True})
            else:
                config.config.update({"publish_chat_admin": False})


    logging.info(f"Updated config: {args[0]} = {config.config[args[0]]}")
    await _reply_author(ctx, f"Saved config: {args[0]} = {config.config[args[0]]}")
    db.save_config(config.config)

@client.command(name="config")
async def command_config(ctx, *args):
    """configure some settings on the bot"""
    if ctx.guild:
        roles = []
        for role in ctx.author.roles:
            roles.append(role.name)

        if config.admin_role in roles or \
           _check_user_bot_role(ctx.author.name, 'moderator', True):
            await handle_command_config(ctx, args)
        else:
            await ctx.reply(_("You do not have permission to execute this command."))

    else:
        if config.admin_user == ctx.author.name or \
           _check_user_bot_role(ctx.author.name, 'moderator', True):
            await handle_command_config(ctx, args)
        else:
            await ctx.reply(_("You do not have permission to execute this command."))


@client.command(name="lifetime")
async def command_lifetime(ctx, player: str = None):
    """Command to check server liftime of players"""
    msg_str = None
    # pylint: disable=line-too-long
    if not _check_user_bot_role(ctx.author.name, "user") and not \
        _check_guild_roles(_get_guild_member_roles(ctx.author.name), config.user_role):
        await ctx.reply(_("You do not have permission to invoke this command."))
        return

    db = ScumLogDataManager(config.database_file)
    if player:
        logging.info(f"Get server lifetime for player {player}")
        player_stat = db.get_player_status(player)
        if len(player_stat) > 0:
            lifetime = mytime.convert_time(player_stat[0]["lifetime"])
            msg_str = _("Player {player} lives on server for {lifetime}.").format(player=player, lifetime=lifetime)
        else:
            msg_str = _("Player {player} has no life on this server.").format(player=player)
    else:
        logging.info("Getting all players that visited the server")
        player_stat = db.get_player_status()
        msg_str = _("Following players have a liftime on this server:\n")
        for p in player_stat:
            lifetime = mytime.convert_time(p["lifetime"])
            msg_str += _("{name} lives for {lifetime} on this server.\n").format(name=p['name'], lifetime=lifetime)

    await _reply(ctx, msg_str)
    db.close()
    # pylint: enable=line-too-long

@client.command(name='bunkers')
async def command_bunkers(ctx, bunker: str = None):
    """Command to check Active bunkers"""
    msg_str = None

    if not _check_user_bot_role(ctx.author.name, "user") and not \
        _check_guild_roles(_get_guild_member_roles(ctx.author.name), config.user_role):
        await ctx.reply(_("You do not have permission to invoke this command."))
        return

    db = ScumLogDataManager(config.database_file)
    if bunker:
        logging.info(f"Will get data for Bunker {bunker}")
        b = db.get_active_bunkers(bunker)
        if len(b) > 0:
            if b[0]["active"] == 0:
                msg_str = _("Bunker {bunker} is not active.").format(bunker=bunker)
                if b[0]["next"] > 0:
                    _next = b[0]["timestamp"] + b[0]["next"]
                    msg_str += "\nWill be active @ "
                    msg_str += f"{datetime.fromtimestamp(_next).strftime('%d.%m.%Y - %H:%M:%S')}"
            else:
                msg_str =_("Bunker {bunker} is active.\n").format(bunker=bunker)
                msg_str += f"@ [Coordinates X={b[0]['coordinates']['x']} "
                msg_str += f"Y={b[0]['coordinates']['y']} "
                msg_str += f"Z={b[0]['coordinates']['z']}]"
                msg_str += f"(https://scum-map.com/en/map/place/{b[0]['coordinates']['x']}"
                msg_str += f",{b[0]['coordinates']['y']},3)"
        else:
            msg_str = _("Bunker {bunker} does not exist.").format(bunker=bunker)
    else:
        logging.info("No bunker given, will get all active bunkers.")
        b = db.get_active_bunkers(None)
        if len(b) > 0:
            msg_str = _("Following Bunkers are active.\n")
            for bunk in b:
                msg_str += _("Bunker {bunker} is active.\n").format(bunker=bunk['name'])
                msg_str += f"@ [Coordinates X={bunk['coordinates']['x']} "
                msg_str += f"Y={bunk['coordinates']['y']} "
                msg_str += f"Z={bunk['coordinates']['z']}]"
                msg_str += f"(https://scum-map.com/en/map/place/{b[0]['coordinates']['x']}"
                msg_str += f",{b[0]['coordinates']['y']},3)\n"
        else:
            msg_str = _("No active bunkers found.")

    await _reply(ctx, msg_str)
    db.close()

@client.command(name='online')
async def player_online(ctx, player: str = None):
    """Command to check if player is online"""
    # pylint: disable=line-too-long
    if not _check_user_bot_role(ctx.author.name, "user") and not \
        _check_guild_roles(_get_guild_member_roles(ctx.author.name), config.user_role):
        await ctx.reply(_("You do not have permission to invoke this command."))
        return

    cmd_handler = Online()
    message = cmd_handler.handle_command(player)

    await _reply(ctx, message)

    # pylint: enable=line-too-long

# pylint: disable=line-too-long
@client.command(name='lastseen')
async def player_lastseen(ctx, player: str):
    """Function to check last seen of a player"""
    message = ""

    if not _check_user_bot_role(ctx.author.name, "user") and not \
        _check_guild_roles(_get_guild_member_roles(ctx.author.name), config.user_role):
        await ctx.reply(_("You do not have permission to invoke this command."))
        return

    local_timezone = ZoneInfo('Europe/Berlin')
    logging.info(f"Get status for player {player}")
    db = ScumLogDataManager(config.database_file)
    player_status = db.get_player_status(player)

    if len(player_status) == 0:
        message = _("Error: Player {player} does not exists in Database").format(player=player)
    else:
        if len(player_status) > 1:
            message = _("Multiple players with Name {player} found.\n").format(player=player)
            for p in player_status:
                if p["state"] == 0:
                    state = "offline"
                    lastseen = datetime.fromtimestamp(p["logout_timestamp"],
                                                       local_timezone).strftime('%d.%m.%Y %H:%M:%S')
                else:
                    state = "online"
                    lastseen = _("now")
                message += _("Player: {player} is currently {state} and was last seen {lastseen}.") \
                           .format(player=player, state=state, lastseen=lastseen)
        else:
            if player_status[0]["status"] == 0:
                state = "offline"
                lastseen = datetime.fromtimestamp(player_status[0]["logout_timestamp"],
                                                   local_timezone).strftime('%Y-%m-%d %H:%M:%S')
            else:
                state = "online"
                lastseen = _("now")

            message = _("Player: {player} is currently {state} and was last seen {lastseen}.") \
                      .format(player=player, state=state, lastseen=lastseen)

    await _reply(ctx, message)
    db.close()

@client.command(name='offline')
async def player_offline(ctx, player: str = None):
    """set player or all players offline in database"""
    db = ScumLogDataManager(config.database_file)
    local_timezone = ZoneInfo('Europe/Berlin')
    message = ""

    if not _check_user_bot_role(ctx.author.name, "admin") and not \
        _check_guild_roles(_get_guild_member_roles(ctx.author.name), config.user_role):
        await ctx.reply(_("You do not have permission to invoke this command."))
        return

    if player is not None and player != "all":
        player_status = db.get_player_status(player)
        if len(player_status) == 0:
            message = _("Error: Player {player} does not exists in Database").format(player=player)
        else:
            if len(player_status) > 1:
                message = _("Multiple players with Name {player} found.\n").format(player=player)
            for p in player_status:
                if p["state"] != 0:
                    p["state"] = 0
                    p.update({"timestamp": datetime.now().strftime('%Y.%m.%d-%H.%M.%S')})
                    p.update({"coordinates":{
                        "x": 0,
                        "y": 0,
                        "z": 0
                    }})
                    lastseen = _("now")
                    message += _("Player: {player} is set as offline and was last seen {lastseen}.") \
                               .format(player=player, lastseen=lastseen)
                    db.update_player(p)
                else:
                    lastseen = datetime.fromtimestamp(p["logout_timestamp"],
                                                   local_timezone).strftime('%Y-%m-%d %H:%M:%S')
                    message += _("Player: {player} is already offline and was last seen {lastseen}.") \
                               .format(player=player, lastseen=lastseen)
    else:
        player_status = db.get_player_online_status()
        for p in player_status:
            if p["state"] != 0:
                p["state"] = 0
                p.update({"coordinates":{
                    "x": 0,
                    "y": 0,
                    "z": 0
                }})
                p.update({"timestamp": datetime.now().strftime('%Y.%m.%d-%H.%M.%S')})
                message += _("Player: {player} is set as offline.\n") \
                           .format(player=p["name"])
                db.update_player(p)

    if player is None:
        message = _("Need either player name or 'all'!")

    if len(message) > 0:
        await _reply_author(ctx, message)
    else:
        message = _("No players were online!")
        await _reply_author(ctx, message)

@client.command(name=HELP_COMMAND)
async def bot_help(ctx):
    """Help command"""

    msg_str = _("Hi, {author}. My Name is {user}.\n").format(author=ctx.author, user=client.user)
    msg_str += _("You can call me with following commands:\n")

    await _reply(ctx, msg_str)

    msg_str = _("!online <player name> - I will tell you if the")
    msg_str += _("player with <name> is online on the SCUM server\n")

    await _reply(ctx, msg_str)

    msg_str = _("!lastseen <player name> - I will tell you when I have seen <playername>")
    msg_str += _("on the SCUM Server\n")

    await _reply(ctx, msg_str)

    msg_str = _("!bunkers <bunker name> - I will tell you if the <bunker name> is active.\n")
    msg_str += _("But the <bunker name> is optional. Without I unveil the secret and give")
    msg_str += _(" you all active bunkers.")

    await _reply(ctx, msg_str)

    msg_str = _("I will also report bunker openening, kills and players joining to and disconnecting ")
    msg_str += _("from the SCUM Server.")

    await _reply(ctx, msg_str)
    # pylint: enable=line-too-long

@client.command(name='roll_dice', help='Simulates rolling dice.')
async def roll(ctx, number_of_dice: int, number_of_sides: int):
    """Yeah, rolling a dice"""
    dice = [
        str(random.choice(range(1, number_of_sides + 1)))
        for _ in range(number_of_dice)
    ]
    await _reply(ctx, ', '.join(dice))

@client.event
async def on_command_error(ctx, error):
    """Is called when commands have errors"""
    if isinstance(error, commands.errors.CheckFailure):
        await ctx.send(_('You do not have the correct role for this command.'))
    elif isinstance(error, commands.MissingRequiredArgument):
        await ctx.send(_("'{error}' is a required argument.").format(error=error.param.name))
    else:
        # All unhandled errors will print their original traceback
        logging.error(f'Ignoring exception in command {ctx.command}:')
        traceback.print_exception(type(error), error, error.__traceback__, file=sys.stderr)

async def _handle_schduled_restart()-> None:
    db = ScumLogDataManager(config.database_file)
    now = datetime.now().strftime("%H:%M")
    schedule = config.get_restart_schedule()
    for restart in schedule:
        if restart == now:
            player_status = db.get_player_online_status()
            for p in player_status:
                if p["state"] != 0:
                    p["state"] = 0
                    p.update({"coordinates":{
                        "x": 0,
                        "y": 0,
                        "z": 0
                    }})
                    p.update({"timestamp": datetime.now().strftime('%Y.%m.%d-%H.%M.%S')})
                    message = f"Player {p["name"]} is forcibly set as offline due to restart"
                    message += " schedule."
                    logging.info(message)
                    db.update_player(p)

## Start the Program
config = ConfigManager()

localedir = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'locale')
translate = gettext.translation('messages', localedir, fallback=True, languages=[config.language])
translate.install()
_ = translate.gettext

client.run(config.token)
